Managing Cognitive Load
=======================

Maybe a little too specific to my makeup, I'm fairly spectrumy.

I'm going to use the word "programmer" here to mean general knowledge
worker, i.e. people that manage a lot of mental context that can not
all be "loaded" at the same time.  Work that requires context
switches.

Started out as shower idea.  Wasn't able to write it down immediately
so the narrative has faded a bit.

Basically, when you're managing programmers, you're not managing
programmer time in hours, but programmer cognitive load.

Cognitive load meaning the amount of context that needs to be in short
term memory to be able to solve a problem.

Almost all problems in programming require abstraction and modularity
to be feasible: i.e. it needs to be possible to "zoom in" on a
problem, ignoring everything that is not important.

I've been having problems with this, recenty, probably due to the
aging process.  I am 45.  I'm trying to reflect on what is the real
issue, and what would be a way to work with it.


Some ideas.

- Context switches are very expensive.

- The need for frequent context switches is an indication for bad
  modularity or abstraction.  If you have to keep too many details in
  your head at once, you need to split things up into separate systems
  that can be properly abstracted.

- A leaky abstract is sometimes worse than no abstraction at all.

- Make sure you can trust the lower levels of your system.  Often it
  is necessary to temporarily ignore and work around minor
  inconveniences, but they _will_ get in the way in a moment when you
  need a reliable base.  Make a note and fix it!

- Manual processes increase cognitive load: if you have to keep a
  "script" in your head on how to perform menial processes while also
  keeping other context in your head, it is time to automate that
  process, or at least to put safeguards in place such that executing
  the manual process does not require much attention.  E.g. it's ok to
  have to press a sequence of buttons such that it can go into muscle
  memory, and any mistakes are cought by the system.

- Automation is expensive, but errors due to cognitive load that is
  too high are even more expensive.

- Interfacing with people while doing a complex task is often already
  too much!  Especially if your programmer is spectrumy, it can be
  quite a task to perform interaction and mental navigation of a
  system at the same time.

- Understand that when you talk in high level terms, many programmes
  see the lower levels you talk about.  It is possible to make them go
  "tilt" by jumping all over the place, especiall when the system
  isn't completely modular, e.g. when some combinations of high level
  concepts simply do not work.  This is often the case if you depend
  on hardware, or closed source softwre.

- Understand that if you remove a safety net (e.g. some automation, a
  test, some other form of mental offloading or redundancy check), a
  task can suddenly go from trivial to very difficult and draining due
  to the level of extra attention involved.  Things I have run into
  recently: remote hardware debugging, not being able to to 100% rely
  on the accuracy of delegated instructions or observations, suddon
  and frequent changes of plans.
