-module(web_base).
-export([input/2,
         attr_decoder/2,
         input_set_callback/2,
         attr_get/2,
         attr_get_integer/2,
         attr_find/2,
         attr_put/3,
         attr_remove/2,
         attr_merge/2]).
%% Special input types.



input(Types, {Key, {button, Label}}) ->
    true = is_binary(Label),
    {button,
     [{name,encode_key(Types,Key)},
      {value,Label},
      attr_decoder(Types,button)],
     [[Label]]};

input(Types, {Key,{boolean,Value}}) ->
    {input,
     [{name,encode_key(Types, Key)},
      {type, checkbox},
      attr_decoder(Types, boolean)]
     ++ checked(Value),
     []};
input(Types, {Key,{password,Value}}) -> 
    {input,[{name,encode_key(Types, Key)},
            {type, password},
            {value, Value},
            attr_decoder(Types, binary)],
     [[Value]]};
input(Types, {Key,{Type, InitTerm}=TaggedValue}) ->
    BinEncoded = type:encode(TaggedValue),
    Attrs = [{name,encode_key(Types, Key)},
             attr_decoder(Types, Type)],
    case type_spec(Types,Type) of
        {finite, Vals} -> %% Option box for finite types
            {select,
             Attrs,
             [{option,
               case Term of
                   InitTerm -> [{selected,""}];
                   _ -> []
               end,
               [[Option]]} || {Option,Term} <- Vals]};
        _ -> %% Other types use text input
            {input,
             Attrs ++ [{value,BinEncoded}],
             [[BinEncoded]]}
    end.







%% The element is a EXML structure as generated by input/1.  Here we
%% patch in an opaque JavaScript callback based on what makes sense
%% for the type of input.
input_set_callback({T,As,Es},{AttrName,JavaScript}) ->
    %% Attribute specified explicitly
    {T,attr_put(AttrName, JavaScript, As),Es};
input_set_callback({Tag,_,_}=El, JavaScript) ->
    %% Derive attribute from element type.
    AttrName =
        case Tag of
            input  -> onchange;
            select -> onchange;
            button -> onclick
        end,
    input_set_callback(El, {AttrName, JavaScript}).



%% TOOLS
attr_decoder(Types, Type) ->
    {'data-decoder',  %% collected by ws.js code
     apply(Types,encode_type,[Type])}.

encode_key(Types, Key) ->
    apply(Types,encode,[{pterm,Key}]).
type_spec(Types, Type) ->
    apply(Types,type_spec,[Type]).

checked(true)  -> [{checked,checked}];
checked(false) -> [].

%% Some operations on attribute lists.
attr_remove(Key, Attrs) -> lists:keydelete(Key,1,Attrs).
attr_put(Key,Val,Attrs) -> [{Key,Val} | attr_remove(Key,Attrs)].
attr_get(Key,Attrs)     -> proplists:get_value(Key, Attrs).
attr_find(Key,Attrs)    -> case proplists:lookup(Key, Attrs) of
                               {_, Value} -> {ok, Value};
                               none -> {error,{not_found,Key}}
                           end.
attr_merge(InitAttrs, PutAttrs) ->                                   
    lists:foldl(
      fun({Attr,Val},As) -> attr_put(Attr,Val,As) end,
      InitAttrs, PutAttrs).
      
attr_get_integer(Key,Attrs) ->
    list_to_integer(attr_get(Key,Attrs)).
              
