-module(web_base).
-export([input/2,
         attr_decoder/2,
         input_set_callback/2,
         attr_get/2,
         attr_get_integer/2,
         attr_find/2,
         attr_put/3,
         attr_remove/2,
         attr_merge/2,

         %% Cowboy wrappers
         cowboy_http_request/3,
         cowboy_http_reply/3,

         %% HMAC for encoding binary terms in JavaScript strings.
         hmac_key/0, hmac/2, hmac_encode/2, hmac_decode/2

]).
%% Special input types.



input(Types, {Key, {button, Label}}) ->
    true = is_binary(Label),
    {button,
     [{name,encode_key(Types,Key)},
      {value,Label},
      attr_decoder(Types,button)],
     [[Label]]};

input(Types, {Key,{boolean,Value}}) ->
    {input,
     [{name,encode_key(Types, Key)},
      {type, checkbox},
      attr_decoder(Types, boolean)]
     ++ checked(Value),
     []};
input(Types, {Key,{password,Value}}) -> 
    {input,[{name,encode_key(Types, Key)},
            {type, password},
            {value, Value},
            attr_decoder(Types, binary)],
     [[Value]]};
input(Types, {Key,{Type, InitTerm}=TaggedValue}) ->
    BinEncoded = type:encode(TaggedValue),
    Attrs = [{name,encode_key(Types, Key)},
             attr_decoder(Types, Type)],
    case type_spec(Types,Type) of
        {finite, Vals} -> %% Option box for finite types
            {select,
             Attrs,
             [{option,
               case Term of
                   InitTerm -> [{selected,""}];
                   _ -> []
               end,
               [[Option]]} || {Option,Term} <- Vals]};
        _ -> %% Other types use text input
            {input,
             Attrs ++ [{value,BinEncoded}],
             [[BinEncoded]]}
    end.







%% The element is a EXML structure as generated by input/1.  Here we
%% patch in an opaque JavaScript callback based on what makes sense
%% for the type of input.
input_set_callback({T,As,Es},{AttrName,JavaScript}) ->
    %% Attribute specified explicitly
    {T,attr_put(AttrName, JavaScript, As),Es};
input_set_callback({Tag,_,_}=El, JavaScript) ->
    %% Derive attribute from element type.
    AttrName =
        case Tag of
            input  -> onchange;
            select -> onchange;
            button -> onclick
        end,
    input_set_callback(El, {AttrName, JavaScript}).



%% TOOLS
attr_decoder(Types, Type) ->
    {'data-decoder',  %% collected by ws.js code
     apply(Types,encode_type,[Type])}.

encode_key(Types, Key) ->
    apply(Types,encode,[{pterm,Key}]).
type_spec(Types, Type) ->
    apply(Types,type_spec,[Type]).

checked(true)  -> [{checked,checked}];
checked(false) -> [].

%% Some operations on attribute lists.
attr_remove(Key, Attrs) -> lists:keydelete(Key,1,Attrs).
attr_put(Key,Val,Attrs) -> [{Key,Val} | attr_remove(Key,Attrs)].
attr_get(Key,Attrs)     -> proplists:get_value(Key, Attrs).
attr_find(Key,Attrs)    -> case proplists:lookup(Key, Attrs) of
                               {_, Value} -> {ok, Value};
                               none -> {error,{not_found,Key}}
                           end.
attr_merge(InitAttrs, PutAttrs) ->                                   
    lists:foldl(
      fun({Attr,Val},As) -> attr_put(Attr,Val,As) end,
      InitAttrs, PutAttrs).
      
attr_get_integer(Key,Attrs) ->
    list_to_integer(attr_get(Key,Attrs)).
              


%% Key used for term authentication (e.g. closures).
%% Limit time-validity of key to one gw boot session.
%% Failed keys will cause websocket processes to die, disconnecting
%% socket which causes client to reconnect.
hmac_key() ->
    Pid = serv:up(
            hmac_key,
            {handler,
             fun() -> #{ key => crypto:strong_rand_bytes(32) } end,
             fun obj:handle/2}),
    unlink(Pid),
    obj:get(Pid, key).
%% hmac_key() -> <<"oT8LGqAtMTGKyBHqoA7ky3PCzjTN5L">>.
hmac(GetKey,Bin) when is_binary(Bin) -> 
    crypto:hmac(sha256,GetKey(),Bin).

%% Encode/decode for tunneling through JSON, cookies, embedded JS,
%% URLs, ...  Use base64 encoding.

hmac_encode(GetKey,Obj) ->
    Bin = term_to_binary(Obj),
    Hmac = hmac(GetKey,Bin),
    base64:encode(term_to_binary({Bin,Hmac})).

hmac_decode(GetKey,Base64) ->
    {Bin,Hmac} = binary_to_term(base64:decode(Base64)),
    case hmac(GetKey,Bin) of
        Hmac  -> {ok, binary_to_term(Bin)};
        Hmac1 -> {error, {hmac_fail, Hmac, Hmac1}}
    end.




%% Convert Cowboy format for query formats to internal format:
-spec atom_map([{binary(),binary()}]) -> #{ atom() => binary() }.
atom_map(PropList) ->
    maps:from_list(
      [{binary_to_atom(Key,utf8),Val} || {Key,Val} <- PropList]).

cowboy_http_reply(Req, State, Reply) ->
    case Reply of
        %% How to set size?  Likely Content-Length in Headers.
        {fold, Headers, Fold} ->
            %% Generator exposed as a fold taking a foldee with early
            %% abort protocol.  This is necessary to handle remote
            %% connection close.
            {ok, Req2} =  cowboy_req:chunked_reply(200, Headers, Req),
            Fold(fun(Data, _) -> 
                         case cowboy_req:chunk(Data, Req2) of
                             ok -> {next, ok};
                             Error -> 
                                 log:info("chunked_reply: ~p~n",[Error]),
                                 {stop, Error}
                         end
                 end, ok),
            {ok, Req2, State};
        {data, Headers, Data} ->
            %% Plain I/O list
            {ok, Req2} = cowboy_req:reply(200, Headers, Data, Req),
            {ok, Req2, State};
        {data, Code, Headers, Data} ->
            %% Plain I/O list
            {ok, Req2} = cowboy_req:reply(Code, Headers, Data, Req),
            {ok, Req2, State};
        {redirect, URL} ->
            {ok, Req2} =
                cowboy_req:reply(
                  302,
                  [{<<"Location">>, URL}],
                  <<"Redirecting...">>,
                  Req),
            {ok, Req2, State}
    end.
      

%% Wrappers to simplify Cowboy API to what is used in web.erl
cowboy_http_request(Req, Get, Post) ->
    {BinPath,_} = cowboy_req:path_info(Req),
    {Method,_} = cowboy_req:method(Req),
    case Method of
        <<"POST">> ->
            {ok, PostData, _} = cowboy_req:body_qs(Req),
            Post(BinPath, atom_map(PostData));
        <<"GET">> ->
            {QueryVals, _} = cowboy_req:qs_vals(Req),
            {Cookies, _} = cowboy_req:cookies(Req),
            {Referer, _} = cowboy_req:header(<<"referer">>, Req),
            QvMap = maps:merge(
                      #{ referer => Referer,
                         cookies => atom_map(Cookies)},
                      atom_map(QueryVals)),
            %% log:info("qv: ~p~n", [QvMap]),
            Get(BinPath, QvMap)
    end.




%% FIXME: sort out old ideas



%% Convert exml to react instantiation code.  FIXME: just an idea -
%% remains to be seen if this is at all useful.  The main reason would
%% be to compose widgets on a page, directed by Erlang code.
%% rexml(El) ->
%%     rexml("React.createElement",El).
%% rexml(CreateEl, {Tag,Attrs,Children}) ->
%%     io_lib:format(
%%       "~s('~s',~s,~s)",
%%       [CreateEl, Tag,
%%        rexml_list([rexml_attr(Attr) || Attr <- Attrs]),
%%        rexml_list([rexml(CreateEl, Child) || Child <- Children])]);
%% rexml(_, Text) ->
%%     io_lib:format("'~s'",[Text]).
%% rexml_attr({_Tag,_Value}) -> "".
%% rexml_list([]) -> "null";
%% rexml_list([H|T]) -> ["[",H,[[",",E]||E<-T],"]"].

%% td_cell({ID,Content}) ->
%%     td_cell({ID,Content,[]});
%% td_cell({ID,Content,ExtraAttrs}) ->
%%     {td,
%%      [{'data-type','cell'}, %% behavior
%%       {id, ID}] ++ ExtraAttrs,
%%      [[Content]]}.

%% A generalized right fold for EXML elements.  Constructors are
%% optionally picked from the dictionary if they exist, otherwise the
%% element is left intact.


%% %% Default constructor: preserve structure and recurse on elements.
%% exml_cons_rec(Constructors) ->
%%     fun(T,As,Es) ->
%%             {T,As,lists:map(
%%                     fun(E) -> exml_gfoldr(Constructors, E) end,
%%                     Es)}
%%     end.

%% %% Generic: if a constructor is specified, it is assumed to perform
%% %% the recursion.  This allows more control over the iteration.
%% exml_gfoldr(Constructors, {Tag, Attrs, Children}) ->
%%     Cons =
%%         case maps:find(Tag, Constructors) of
%%             {ok, Fun} -> Fun;
%%             _ ->
%%                 case maps:find('_', Constructors) of
%%                     {ok, Fun} -> Fun;
%%                     _ -> exml_cons_rec(Constructors)
%%                 end
%%         end,
%%     Cons(Tag, Attrs, Children);
%% exml_gfoldr(_Constructors, Other) ->
%%     %% FIXME: leaf nodes?
%%     Other.



