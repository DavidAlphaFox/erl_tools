-module(ws_widget).
-export([test/1]).

%% Test widget for multi-process widget approch based on ws.erl infrastructure.

%% The context in which a widget runs constists of:
%% - websocket, talking to web page with a cell called Name
%% - events tagged with Path get sent to the handler
%% - the page contains a cell {id,Path} that we can set
%% - we can use identifiers prefixed with Path for other purposes.

%% To keep things easy to evolve, the EXML generated by the widget is
%% relatively unconstraint apart from the identifiers used for
%% routing.  The focus now is mostly on streamlining message flow
%% between Erlang and JavaScript.  A separate library could be
%% constructed to create layout.

%% Send is JavaScript code that looks something like:
%% "app.send_input(this)", calling into the JavaScript code in js_src


test(#{ ws   := Ws,
        path := Path } = Env) ->

    {handler,
     fun() ->
             Exml = [{pre,[],[[<<"Test Widget">>]]},
                     button(Env, {Path, button123}, <<"Test123">>)],
             %% log:info("~p~n", [{Ws,Path,Exml}]),
             ws:call_exml(Ws, Path, set, Exml),
             #{}
     end,
     fun(Msg, State) ->
             log:info("test_widget: ~p~n", [Msg]),
             %% FIXME: setting button names doesn't seem to work well
             %% this way..  Maybe a problem with cell just setting
             %% text instead of a html element?
             ws:call_exml(Ws, {Path, button123}, set, [{'div',[],[[<<"clicked!">>]]}]),
             State
     end}.


%% Layout.

button(#{ send := Send }, ID, Text) ->
    ID_enc = ws:encode_id(ID),
    {button,
     [{onclick, Send},
      {'data-decoder', button},  %% Type conversion
      {'data-mixin', cell},      %% Allow mutation.
      %%{name, ID_enc},            %% js->e messages
      {id, ID_enc}],             %% e->js messages
     [[Text]]}.
